
public class PartOneStringTable {
	public Record[] table;

	public PartOneStringTable(int maxSize) 
	{
		table = new Record[4*maxSize];

	}


	//
	// Insert a Record r into the table.  Return true if
	// successful, false if the table is full.  You shouldn't ever
	// get two insertions with the same key value, but you may
	// simply return false if this happens.
	//
	public boolean insert(Record r) 
	{ 

		boolean returnCode = true;
		int hashSKey = toHashKey(r.key);
		r.toHashValue = hashSKey;
		int si = baseHash(hashSKey)%table.length;

		int counter = 0;
		if(table[si]==null ||table[si].key.equals("deleted")){
			table[si] = r;

		}
		else{
			boolean b1 = table[si]!=null;
			boolean b2 = table[si].toHashValue!=-1;
			boolean b3 = counter<table.length;
					
			while(b1&&b2&&b3){
				
				if(table[si].key.equals(r.key) ){
					returnCode = false;
					break;
				}
				
				si = (si+stepHash(hashSKey))%(table.length);
				counter++;
				
			     b1 = table[si]!=null;
			     if (b1){
			    	 b2 = table[si].toHashValue!=-1;
					 b3 = counter<table.length;
			     }
				 
			}
			if (counter<table.length){
				table[si] = r;
			}
			else{
				returnCode = false; 
			}
		}

		return returnCode; 
	}


	//
	// Delete a Record r from the table.  Note that you'll have to
	// find the record first unless you keep some extra information
	// in the Record structure.
	//
	public void remove(Record r) 
	{
		Record f = find(r.key);
		if (f != null){
			r.delete();
		}

	}


	//
	// Find a record with a key matching the input.  Return the
	// record if it exists, or null if no matching record is found.
	//
	public Record find(String key) 
	{
		int hashSKey = toHashKey(key);
		int si = baseHash(hashSKey)%table.length;

		int counter = 0;
		if (table[si]!=null){
			if (table[si].toHashValue==hashSKey && table[si].key.equals(key)){	
				return table[si];
				
			}
			else{
				boolean b1 = table[si]!=null;
				boolean b2 = table[si].toHashValue!=hashSKey;
				boolean b3 = !table[si].key.equals(key);
				boolean b4 = counter<table.length;
				
				while(b1&&(b2||(!b2&&b3))&&b4){
					si = (si+stepHash(hashSKey))%(table.length);
					counter++;
					
					b1 = table[si]!=null;
					if(b1){
						b2 = table[si].toHashValue!=hashSKey;
						b3 = !table[si].key.equals(key);
						b4 = counter<table.length;
					}
									
				}

				if (counter<table.length){
					if(table[si] == null){
						return null;
					}
					else {
						return table[si];
					}
				}
				else {
					return null;
				}
			}
		}

		else{
			return null;

		}

	}


	///////////////////////////////////////////////////////////////////////


	// Convert a String key into an integer that serves as input to hash
	// functions.  This mapping is based on the idea of a linear-congruential
	// pesudorandom number generator, in which successive values r_i are 
	// generated by computing
	//    r_i = ( A * r_(i-1) + B ) mod M
	// A is a large prime number, while B is a small increment thrown in
	// so that we don't just compute successive powers of A mod M.
	//
	// We modify the above generator by perturbing each r_i, adding in
	// the ith character of the string and its offset, to alter the
	// pseudorandom sequence.
	//
	int toHashKey(String s)
	{
		int A = 1952786893;
		int B = 367257;
		int v = B;

		for (int j = 0; j < s.length(); j++)
		{
			char c = s.charAt(j);
			v = A * (v + (int) c + j) + B;
		}

		if (v < 0) v = -v;
		return v;
	}

	int baseHash(int hashKey)
	{
		// Fill in your own hash function here
		double A1 = (Math.sqrt(5)-1)/2;
		int h1 = (int)(Math.floor(table.length*(hashKey*A1-Math.floor(hashKey*A1))));

		return h1;
	}

	int stepHash(int hashKey)
	{
		// Fill in your own hash function here
		double A2 = (Math.sqrt(2))/2;
		double f =hashKey*A2-Math.floor(hashKey*A2);
		double m = f*table.length;
		int h2 = (int)(Math.floor(m))+1;

		return h2;  	

	}



}
